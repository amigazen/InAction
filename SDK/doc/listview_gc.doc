TABLE OF CONTENTS

listview.gadget/GetListViewClass
listview.gadget/listview.gadget
listview.gadget/Tree_AddHead
listview.gadget/Tree_AddSubHead
listview.gadget/Tree_AddSubTail
listview.gadget/Tree_AddTail
listview.gadget/Tree_Insert
listview.gadget/Tree_NewList
listview.gadget/Tree_NextNode
listview.gadget/Tree_NextSubNode
listview.gadget/Tree_RemHead
listview.gadget/Tree_Remove
listview.gadget/Tree_RemSubHead
listview.gadget/Tree_RemSubTail
listview.gadget/Tree_RemTail
listview.gadget/GetListViewClass             listview.gadget/GetListViewClass

   NAME   
        GetListViewClass -- creates listview class (V37)

   SYNOPSIS
        listview_class = GetListViewClass();
        D0

        Class *GetListViewClass( void );

   FUNCTION
        Obtains pointer to listview.gadget class for use with
        intuition.library/NewObject(). Call this function only at start
        of program.

   RESULT
        listview_class - pointer to listview class

   SEE ALSO

listview.gadget/listview.gadget               listview.gadget/listview.gadget

   NAME   
        listview.gadget -- create enchanced listview gadget (V37)

   FUNCTION
        The listview class provides capability to create tree and multi
        column lists and show them in BOOPSI listview gadget. Tree lists are
        similiar to standard exec lists, but some changes has been made. You
        can use them on standard listview gadget but then you can't use all
        features of tree nodes. To browse through tree list you should use
        Tree_NextNode(). This function can easly give you next open node in
        tree (hidden nodes are NOT processed!). If you want browse thru all
        nodes do it as in standard lists but you must check for parent nodes
        (leafs are terminated by pointer to parent node). Tree node looks
        like this:
        
            struct LVNode
            {
              struct LVNode *ln_Succ;  // Pointer to next node in the list.
                               // If this is last node in the leaf it points
                               // to the parent node, otherwise it points to
                               // lh_Tail in list structure.
              struct LVNode *ln_Pred;  // Pointer to previous node in the
                               // list. If this is first node in tree it
                               // points to the parent node, otherwise it
                               // points to NULL
              UWORD ln_Flags;  // Flags of the node. LV_SELECT is set if node
                               // is selected. LV_OPEN is set if leaf is
                               // open.
              STRPTR ln_Name;  // Pointer to NULL terminated string. In
                               // multicolumn lists collumns are separated
                               // by special character defined in NewObject()
              struct LVNode *ln_Sub;   // Pointer to sub node in the list.
                               // NULL if there are no sub nodes.
              struct LVNode *ln_Parent; // Pointer to parent node. NULL if
                               // there is no parent nodes
              UBYTE ln_Indent; // Private! Don't change. This is indent of
                               // sub nodes.
            };

        Why tree node linking is so strange? And why I simply don't use list
        structures for sub nodes? It's easy to understand. Creating for every
        leaf new list is hard to make, you need a lot of NewList()
        initializations. Also, when entering to leafs you must remember
        parent node. With this style of lists you can browse tree list like
        normal lists (you can indicate a new leaf by checking ln_Indent
        field), it's faster and easier to make such lists. Unfortunately you
        need a new functions for list management. Root list is compatible
        with exec list, but use Tree_#?() functions instead. You can also use
        a functions designed for sub nodes on root list.
        ln_Name and LIST_Format strings have basic support of formatting:
        ESCc - center, ESCl - left, ESCr - right, ESC<num> - pen number (only
        0 to 9), ESCp - plain, ESCb - bold, ESCi - italic, ESCu - underline.


   TAGS
        LIST_Labels (struct LVList *) - Pointer to the list of nodes.
            Don't try to supply standard lists.
            Default for this tag is NULL. Applicability is (IS). (V37)

        LIST_Top (ULONG) - Number of top shown node.
            Default for this tag is 0. Applicability is (ISG). (V37)

        LIST_ReadOnly (BOOL) - Make listview gadget read only.
            Default for this tag is FALSE. Applicability is (I). (V37)

        LIST_Border (BOOL) - Set it to FALSE if you don't want a
            border around listview gadget.
            Default for this tag is TRUE. Applicability is (I). (V37)

        LIST_Selected (struct LVNode *) - Returns pointer to currently
            selected node in the list. In multiselect lists use LV_SELECT
            flag in ln_Flags field instead.
            Default for this tag is NULL. Applicability is (G). (V37)

        LIST_Columns (ULONG) - Number of columns in listview gadget.
            Default for this tag is 1. Applicability is (I). (V37)

        LIST_TextFont (struct TextFont *) - Font used for rendering all
            texts.
            Default for this tag is NULL. Applicability is (I). (V37)

        LIST_ShowTreeLines (BOOL) - If you want lines in tree gadget set it
            to TRUE.
            Default for this tag is FALSE. Applicability is (IG). (V37)

        LIST_TabChar (STRPTR) - Character used to separate columns.
            Default for this tag is '\t'. Applicability is (I). (V37)

        LIST_Format (STRPTR) - Pointer to titles of columns. Titles are
            separated by '|' character. Set to NULL if you don't want
            titles. Strings can be formatted.
            Default for this tag is NULL. Applicability is (I). (V37)

        LIST_Visible (ULONG) - Number of visible lines.
            Applicability is (G). (V37)

        LIST_Total (ULONG) - Number of all open nodes in the list.
            Applicability is (G). (V37)

        LIST_IsTree (BOOL) - You must set this to TRUE if you use tree
            lists.
            Applicability is (IG). (V37)

        LIST_HookSub (struct Hook *) - Callback routine called when
            leaf is opened (TLV_OPENSUB, TLVSubMsg) or closed
            (TLV_CLOSESUB, TLVSubMsg). You can use this callback
            to use dynamicially generated trees like directory list.
            Remember: sub nodes must have at least one node (make
            dummy node for this). Callback must return TLVCB_OK when
            message was processed.
            Applicability is (ISG). (V37)

        LIST_HookDraw (struct Hook *) - Callback routine called when
            node is rendered (TLV_DRAW, TLVDrawmsg). Callback must
            return TLVCB_OK when message was processed.
            Applicability is (ISG). (V37)

        LIST_HookEdit (struct Hook *) - Callback routine called when
            node is going to be edited and when was edited. First
            TLV_DOEDIT (TLVEditMsg) method is called, you must check
            tlvm_Column field end tell to listview that you want to edit
            this column or not. Return TLVCB_OK to not edit column or
            TLVCB_UNKNOWN to edit column.
            After the node was edited TLV_EDIT method is called. You
            need to manually replace tlvm_Node->ln_Name with new string
            in tlvm_String adding strings from other columns. Callback
            must return TLVCB_OK when message was processed.
            Setting this hook makes listview editable by user.
            Edit string gadget is created and added at the end of list of
            all gadgets. So, use it carefully because you can remove
            listview from window but string can stay in the list of
            gadgets (it's only invisble for you). String is removed and
            disposed when listview is disposed.
            Applicability is (ISG). (V37)

        LIST_ColumnsPos (UWORD *) - Table of column positions. Column 0
            has position always equal to 0 and last column always equal
            to width of gadget. Two columned listview has three positions.
            Applicability is (ISG). (V37)

  SEE ALSO
        gadgets/listview.h

listview.gadget/Tree_AddHead                     listview.gadget/Tree_AddHead

   NAME   
        Tree_AddHead -- insert node at the head of a list (V37)

   SYNOPSIS
        Tree_AddHead(list,node);
                     A0   A1

        void Tree_AddHead(struct LVList *,struct LVNode *);

   FUNCTION
        Add a node to the head of a doubly linked list.

   INPUTS
        list - a pointer to list to the target list header
        node - the node to insert at head

   SEE ALSO
        Tree_AddTail, Tree_Insert, Tree_Remove, Tree_RemHead,
        Tree_RemTail

listview.gadget/Tree_AddSubHead               listview.gadget/Tree_AddSubHead

   NAME   
        Tree_AddSubHead -- insert node at the head of a sub list (V37)

   SYNOPSIS
        Tree_AddSubHead(list,parent,node);
                        A0   A1     A2

        void Tree_AddSubHead(struct LVList *,struct LVNode *,struct LVNode *)
;

   FUNCTION
        Add a node to the head of a sub list.

   INPUTS
        list - a pointer to list to the target list header
        parent - a parent node of the sub list to insert the node to
                 May be NULL.
        node - the node to insert at head

   SEE ALSO
        Tree_AddSubTail, Tree_Insert, Tree_Remove, Tree_RemSubHead,
        Tree_RemSubTail

listview.gadget/Tree_AddSubTail               listview.gadget/Tree_AddSubTail

   NAME   
        Tree_AddSubTail -- append node to tail of a sub list (V37)

   SYNOPSIS
        Tree_AddSubTail(list,parent,node);
                        A0   A1     A2

        void Tree_AddSubTail(struct LVList *,struct LVNode *,struct LVNode *)
;

   FUNCTION
        Add a node to the tail of a sub list.

   INPUTS
        list - a pointer to the target list header
        parent - a parent node of the sub list to append the node to.
                 May be NULL.
        node - a pointer to the node to insert at tail of the sub list

   SEE ALSO
        Tree_AddSubHead, Tree_Insert, Tree_Remove, Tree_RemSubHead,
        Tree_RemSubTail

listview.gadget/Tree_AddTail                     listview.gadget/Tree_AddTail

   NAME   
        Tree_AddTail -- append node to tail of a list (V37)

   SYNOPSIS
        Tree_AddTail(list,node);
                     A0   A1

        void Tree_AddTail(struct LVList *,struct LVNode *);

   FUNCTION
        Add a node to the tail of a doubly linked list.

   INPUTS
        list - a pointer to the target list header
        node - a pointer to the node to inser at tail of the list

   SEE ALSO
        Tree_AddHead, Tree_Insert, Tree_Remove, Tree_RemHead,
        Tree_RemTail

listview.gadget/Tree_Insert                       listview.gadget/Tree_Insert


   NAME
        Tree_Insert -- insert a node into a list or sub list (V37)

   SYNOPSIS
        Tree_Insert(list, node, listNode)
                    A0    A1    A2

        void Tree_Insert(struct LVList *, struct LVNode *, struct LVNode *);

   FUNCTION
        Insert a node into a doubly linked list AFTER a given node
        position.  Insertion at the head of a list is possible by passing a
        zero value for listNode, though the AddHead function is slightly
        faster for that special case.

   INPUTS
        list - a pointer to the target list header
        node - the node to insert
        listNode - the node after which to insert

    SEE ALSO
        Tree_AddHead, Tree_AddSubHead, Tree_AddSubTail, Tree_AddTail,
        Tree_RemHead, Tree_Remove, Tree_RemSubHead, Tree_RemSubTail,
        Tree_RemTail

listview.gadget/Tree_NewList                     listview.gadget/Tree_NewList

   NAME   
        Tree_NewList -- initialize list for use (V37)

   SYNOPSIS
        Tree_NewList(list);
                     A0

        void Tree_NewList(struct LVList *);

   FUNCTION
        Initializes list structure to use.

   INPUTS
        list - a pointer to the list

   SEE ALSO

listview.gadget/Tree_NextNode                   listview.gadget/Tree_NextNode

   NAME   
        Tree_NextNode -- get pointer to next node (V37)

   SYNOPSIS
        nextnode = Tree_NextNode(node);
        D0                       A0

        struct LVNode *Tree_NextNode(struct LVNode *);

   FUNCTION
        Returns pointer to next node in the list. If node is open
        it will enter in it and process sub nodes otherwise sub nodes
        will be skipped.
        You can simply process all open nodes using for() instruction:

        for(node=list.lh_Head;Tree_NextNode(node);node=Tree_NextNode(node))
        {
          // do here something with node
        } 

   INPUTS
        node - a pointer to the node

   RESULT
        nextnode - a pointer to the next node or NULL if there is no more
                   nodes

   SEE ALSO
        Tree_NextSubNode

listview.gadget/Tree_NextSubNode             listview.gadget/Tree_NextSubNode

   NAME   
        Tree_NextSubNode -- get pointer to next node or sub node (V37)

   SYNOPSIS
        nextnode = Tree_NextSubNode(node);
        D0                          A0

        struct LVNode *Tree_NextSubNode(struct LVNode *);

   FUNCTION
        Returns pointer to next node in the list.
        You can simply process all nodes using for() instruction:

        for(node=list.lh_Head;Tree_NextSubNode(node); \
                              node=Tree_NextSubNode(node))
        {
          // do here something with node
        } 

   INPUTS
        node - a pointer to the node

   RESULT
        nextnode - a pointer to the next node or NULL if there is no more
                   nodes

   SEE ALSO
        Tree_NextNode

listview.gadget/Tree_RemHead                     listview.gadget/Tree_RemHead

   NAME   
        Tree_RemHead -- remove the head node from a list (V37)

   SYNOPSIS
        node = Tree_RemHead(list);
        D0                  A0

        struct LVNode *Tree_RemHead(struct LVList *);

   FUNCTION
        Get a pointer to the head node and remove it from the list.

   INPUTS
        list - a pointer to the target list header

   RESULT
        node - the node removed or zero when empty list

   SEE ALSO
        Tree_AddHead, Tree_AddTail, Tree_Insert, Tree_Remove,
        Tree_RemTail

listview.gadget/Tree_Remove                       listview.gadget/Tree_Remove

   NAME   
        Tree_Remove -- remove a node from a list (V37)

   SYNOPSIS
        Tree_Remove(node);
                    A0

        void Tree_Remove(struct LVNode *);

   FUNCTION
        Unlink a node with all sub nodes whatever list it is in.
        Nodes that are not part of a list must not be passed to this
        function!

   INPUTS
        node - the node to remove

   SEE ALSO
        Tree_AddHead, Tree_AddTail, Tree_Insert, Tree_RemHead,
        Tree_RemTail

listview.gadget/Tree_RemSubHead               listview.gadget/Tree_RemSubHead

   NAME   
        Tree_RemSubHead -- remove the head node from a sub list (V37)

   SYNOPSIS
        node = Tree_RemSubHead(node);
        D0                     A0

        struct LVNode *Tree_RemSubHead(struct LVNode *);

   FUNCTION
        Get a pointer to the head sub node and remove it from the list.

   INPUTS
        node - a pointer to the target node header

   RESULT
        node - the node removed or zero when empty list

   SEE ALSO
        Tree_AddSubHead, Tree_AddSubTail, Tree_Insert, Tree_Remove,
        Tree_RemSubTail

listview.gadget/Tree_RemSubTail               listview.gadget/Tree_RemSubTail

   NAME   
        Tree_RemSubTail -- remove the tail node from a sub list (V37)

   SYNOPSIS
        node = Tree_RemSubTail(node);
        D0                     A0

        struct LVNode *Tree_RemSubTail(struct LVNode *);

   FUNCTION
        Get a pointer to the tail sub node and remove it from the list.

   INPUTS
        node - a pointer to the target node header

   RESULT
        node - the node removed or zero when empty list

   SEE ALSO
        Tree_AddSubHead, Tree_AddSubTail, Tree_Insert, Tree_Remove,
        Tree_RemSubHead

listview.gadget/Tree_RemTail                     listview.gadget/Tree_RemTail

   NAME   
        Tree_RemTail -- remove the tail node from a list (V37)

   SYNOPSIS
        node = Tree_RemTail(list);
        D0                  A0

        struct LVNode *Tree_RemTail(struct LVList *);

   FUNCTION
        Get a pointer to the tail node and remove it from the list.

   INPUTS
        list - a pointer to the target list header

   RESULT
        node - the node removed or zero when empty list

   SEE ALSO
        Tree_AddHead, Tree_AddTail, Tree_Insert, Tree_Remove,
        Tree_RemHead

